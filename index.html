<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üè≠ LƒÉng K√≠nh Ng∆∞·ªùi Ti√™u D√πng</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
:root {
  --primary-color: #6d28d9;
  --secondary-color: #a78bfa;
  --background-gradient: linear-gradient(135deg, #fff8dc, #ffe4e6);
  --card-background: #ffffff;
  --text-color: #333333;
  --success-color: #10b981;
  --error-color: #ef4444;
  --border-radius-lg: 15px;
  --border-radius-md: 10px;
  --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
  --shadow-lg: 0 8px 25px rgba(0,0,0,0.15);
  --highlight: #fde047;
}
body {
  font-family: 'Roboto', sans-serif;
  background: var(--background-gradient);
  text-align: center;
  margin: 0;
  padding: 20px;
  color: var(--text-color);
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  box-sizing: border-box;
}
h1 { color: var(--primary-color); font-size: 2.5em; margin-bottom: 30px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
h2 { color: var(--primary-color); margin-top: 20px; }

#menu, #game-container { background: var(--card-background); border-radius: var(--border-radius-lg); box-shadow: var(--shadow-lg); padding: 30px; max-width: 700px; width: 96%; margin-top: 20px; }
#menu h3 { color: var(--text-color); margin-bottom: 15px; }
input[type="text"], select {
  padding: 12px 15px;
  border: 1px solid #d1d5db;
  border-radius: var(--border-radius-md);
  width: calc(100% - 30px);
  margin-bottom: 15px;
  font-size: 1em;
  box-sizing: border-box;
  transition: border-color 0.3s ease;
}
input[type="text"]:focus, select:focus { border-color: var(--primary-color); outline: none; box-shadow: 0 0 0 3px rgba(109, 40, 217, 0.12); }

img#biscuitImage { max-width: 100%; height: auto; border-radius: var(--border-radius-md); margin-bottom: 25px; box-shadow: var(--shadow-md); background-color: #f0f0f0; min-height: 220px; object-fit: contain; }

button { padding: 12px 25px; border: none; border-radius: var(--border-radius-md); margin: 8px; background-color: var(--primary-color); color: white; font-weight: bold; font-size: 1.05em; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; display: inline-flex; align-items: center; gap: 8px; }
button:hover { background-color: var(--secondary-color); transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
button:active { transform: translateY(0); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }

button.answer-btn-good { background-color: var(--success-color); }
button.answer-btn-good:hover { background-color: #059669; }
button.answer-btn-bad { background-color: var(--error-color); }
button.answer-btn-bad:hover { background-color: #dc2626; }
button.next-btn { background-color: var(--primary-color); margin-top: 20px; }

#result { font-size: 1.2em; font-weight: bold; margin-top: 20px; min-height: 28px; }
#score, #timer { font-size: 1.1em; font-weight: bold; margin-top: 10px; }
#score { color: var(--success-color); }
#timer { color: var(--error-color); margin-bottom: 10px; }

#errorSection { background-color: #fefce8; border: 1px solid #fde68a; border-radius: var(--border-radius-md); padding: 15px; margin-top: 20px; text-align:left; display:none; }
#errorSection p { color: #b45309; font-weight: bold; margin-bottom: 10px; }

table { width: 100%; border-collapse: collapse; margin-top: 18px; border-radius: var(--border-radius-md); overflow: hidden; box-shadow: var(--shadow-md); }
th, td { border: 1px solid #e5e7eb; padding: 12px 10px; font-size: 0.95em; text-align: left; }
th { background: var(--primary-color); color: white; font-weight: bold; text-transform: uppercase; }
tr:nth-child(even) { background-color: #f9fafb; }
tr:hover { background-color: #f3f4f6; }
.highlight { background-color: var(--highlight) !important; }

@media (max-width: 600px) {
  h1 { font-size: 2em; }
  button { width: calc(100% - 16px); margin-left: 0; margin-right: 0; }
  input[type="text"], select { width: 100%; }
}

#ranking-wrapper { display: none; margin-top: 20px; max-width: 700px; width: 96%; }
#ranking-controls { display:flex; gap:10px; align-items:center; justify-content:flex-start; margin-top:8px; }
</style>
</head>
<body>

<h1>üè≠ LƒÉng K√≠nh Ng∆∞·ªùi Ti√™u D√πng</h1>

<!-- MENU -->
<div id="menu">
  <h3>Nh·∫≠p t√™n c·ªßa b·∫°n:</h3>
  <input type="text" id="playerName" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n...">
  <h2>Ch·ªçn ch·∫ø ƒë·ªô ch∆°i:</h2>
  <button onclick="startGame('sanpham')"><i class="fas fa-cookie-bite"></i> S·∫£n ph·∫©m</button>
  <button onclick="startGame('baobi1')"><i class="fas fa-box"></i> Bao b√¨ c·∫•p 1</button>
  <button onclick="startGame('baobi2')"><i class="fas fa-boxes"></i> Bao b√¨ c·∫•p 2</button>
</div>

<!-- GAME -->
<div id="game-container" style="display:none;">
  <div id="timer">Th·ªùi gian: 20s</div>
  <img id="biscuitImage" src="" alt="·∫¢nh l·ªói QC">
  <div>
    <button class="answer-btn-good" onclick="checkAnswer(true)"><i class="fas fa-check-circle"></i> ƒê·∫°t</button>
    <button class="answer-btn-bad" onclick="checkAnswer(false)"><i class="fas fa-times-circle"></i> L·ªói</button>
  </div>

  <div id="errorSection">
    <p>Ch·ªçn lo·∫°i l·ªói:</p>
    <select id="errorSelect"></select>
    <br>
    <button class="next-btn" onclick="submitError()"><i class="fas fa-check"></i> X√°c nh·∫≠n</button>
  </div>

  <div id="result"></div>
  <div id="score">ƒêi·ªÉm: 0</div>
  <br>
  <button class="next-btn" onclick="nextImage()"><i class="fas fa-arrow-right"></i> ·∫¢nh ti·∫øp theo</button>
</div>

<!-- RANKING -->
<div id="ranking-wrapper">
  <div id="ranking-box" style="background: white; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.15); padding:20px; max-width:700px; width:100%; text-align:left;">
    <h2 style="margin-top:0;">üéâ Ho√†n th√†nh!</h2>
    <p id="finalScoreText" style="font-weight:bold;"></p>
    <div id="ranking-controls">
      <label for="rankingFilter" style="margin-right:8px;">L·ªçc m·ª•c ch∆°i:</label>
      <select id="rankingFilter" onchange="filterRanking()">
        <option value="">T·∫•t c·∫£</option>
        <option value="sanpham">S·∫£n ph·∫©m</option>
        <option value="baobi1">Bao b√¨ c·∫•p 1</option>
        <option value="baobi2">Bao b√¨ c·∫•p 2</option>
      </select>
    </div>
    <div id="ranking-table-wrap" style="margin-top:12px;">
      <table id="rankingTable"></table>
    </div>
    <div style="margin-top:12px;">
      <button onclick="location.reload()"><i class="fas fa-redo"></i> Ch∆°i l·∫°i</button>
    </div>
  </div>
</div>

<script>
const CONFIG = {
  baseURL: "https://raw.githubusercontent.com/lehienbqc53-cpu/Game-solite/main/images/",
  scriptURL: "https://script.google.com/macros/s/AKfycbyIPxOrMLBfJzkaqUGtrXhxi7BlyTI3qJSEvuSvR9vChhLLUkJKFnDqv-Ki51yR4rlk2A/exec",
  timerDuration: 20
};

/* =========================
   Danh s√°ch ·∫£nh gi·ªØ nguy√™n nh∆∞ code g·ªëc
   ========================= */
const ERROR_DATA = {
  sanpham: {
    errors: [
      { src: "Banh_Mau_Khong_Dat.webp", correctError: "B√°nh m√†u kh√¥ng ƒë·∫°t" },
      { src: "Banh_Khong_Dat_Bong_Khi.webp", correctError: "B√°nh kh√¥ng ƒë·∫°t b√≥ng kh√≠" },
      { src: "Banh_Vet_Nut_Khong_Dat.webp", correctError: "B√°nh v·∫øt n·ª©t kh√¥ng ƒë·∫°t" },
      { src: "Banh_co_kem_khong_Dat.webp", correctError: "B√°nh c√≥ kem kh√¥ng ƒë·∫°t" },
      { src: "Banh_vo_Khong_Dat.webp", correctError: "B√°nh v·ª° kh√¥ng ƒë·∫°t" },
      { src: "Banh_Troc_Vo_Khong_Dat.webp", correctError: "B√°nh tr√≥c v·ªè kh√¥ng ƒë·∫°t" }
    ],
    goods: ["Banh_Mau_Dat.webp","Banh_Co_Kem_Dat.webp","Banh_Troc_Vo_Dat.webp","Banh_Vo_Dat.webp","Banh_Vet_Nut_Dat.webp","Banh_Dat_Bong_Khi.webp"]
  },
  baobi1: {
    errors: [
      { src: "Duong_Han_Qua_Nhiet.webp", correctError: "ƒê∆∞·ªùng h√†n qu√° nhi·ªát" },
      { src: "Duong_Han_Yeu.webp", correctError: "ƒê∆∞·ªùng h√†n y·∫øu" },
      { src: "Duong_han_can_trang_rach.webp", correctError: "ƒê∆∞·ªùng h√†n c·∫•n tr·∫Øng r√°ch" },
      { src: "Sai_Nhoe_Date.webp", correctError: "Sai, nh√≤e date" },
      { src: "Duong_han_bung_dau_duoi_lech.webp", correctError: "ƒê∆∞·ªùng h√†n bung ƒë·∫ßu, ƒë·∫ßu l·ªách" },
      { src: "Bang_Keo_noi_cuon.webp", correctError: "BƒÉng keo n·ªëi cu·ªôn" },
      { src: "Xep_Ly_xi.webp", correctError: "X·∫øp ly x√¨" }
    ],
    goods: ["Banh_dat.webp"]
  },
  baobi2: {
    errors: [
      { src: "Sap_xep_goi_banh_khong_dat.webp", correctError: "S·∫Øp x·∫øp g√≥i b√°nh kh√¥ng ƒë·∫°t" },
      { src: "Khay_Mop_Meo_Cong_Rach.webp", correctError: "Khay m√≥p m√©o cong r√°ch" },
      { src: "Mang_Co_Nhan_Rach.webp", correctError: "M√†ng co nhƒÉn r√°ch" },
      { src: "Sai_Nhoe_date.webp", correctError: "Sai, nh√≤e date" },
      { src: "Bang_Keo_nho_5mm_khong_dat.webp", correctError: "BƒÉng keo kh√¥ng ƒë·∫°t 5cm" },
      { src: "Thung_Mop_Meo.webp", correctError: "Th√πng m√≥p m√©o" },
      { src: "Thung_Thieu_Sai_date.webp", correctError: "Th√πng thi·∫øu, sai date" },
      { src: "Sai_Thieu_date_hop.webp", correctError: "Sai, thi·∫øu date h·ªôp" },
      { src: "Hu_Hong_Duong_Mo.webp", correctError: "H∆∞ h·ªèng ƒë∆∞·ªùng m·ªü" },
      { src: "Lech_Nap_Hop.webp", correctError: "L·ªách n·∫Øp h·ªôp" },
      { src: "Nap_hop_dan_khong_dung.webp", correctError: "N·∫Øp h·ªôp d√°n kh√¥ng ƒë√∫ng" },
      { src: "Hu_hong_goc.webp", correctError: "H∆∞ h·ªèng g√≥c h·ªôp" },
      { src: "Hop_Bien_dang.webp", correctError: "H·ªôp bi·∫øn d·∫°ng" },
      { src: "Duong_han_keo_yeu_lem_keo.webp", correctError: "ƒê∆∞·ªùng h√†n keo y·∫øu, lem keo" }
    ],
    goods: ["Hop_Dat.webp"]
  }
};

/* Mapping ch·∫ø ƒë·ªô */
const MODE_MAP = { sanpham:"S·∫£n ph·∫©m", baobi1:"Bao b√¨ c·∫•p 1", baobi2:"Bao b√¨ c·∫•p 2" };
const REVERSE_MODE_MAP = Object.entries(MODE_MAP).reduce((a,[k,v])=>{ a[v]=k; return a;}, {});

/* =========================
   QCGame Class
   ========================= */
class QCGame {
  constructor() {
    this.images=[];
    this.mode="";
    this.current=0;
    this.score=0;
    this.answered=false;
    this.timeLeft=CONFIG.timerDuration;
    this.timerInterval=null;
    this.playerName="";
    this.dom={
      menu:document.getElementById("menu"),
      gameContainer:document.getElementById("game-container"),
      playerNameInput:document.getElementById("playerName"),
      timerElement:document.getElementById("timer"),
      imgElement:document.getElementById("biscuitImage"),
      resultElement:document.getElementById("result"),
      scoreElement:document.getElementById("score"),
      errorSection:document.getElementById("errorSection"),
      errorSelect:document.getElementById("errorSelect"),
      rankingWrapper:document.getElementById("ranking-wrapper"),
      finalScoreText:document.getElementById("finalScoreText"),
      rankingTable:document.getElementById("rankingTable"),
      rankingFilter:document.getElementById("rankingFilter")
    };
    window.startGame=this.startGame.bind(this);
    window.checkAnswer=this.checkAnswer.bind(this);
    window.submitError=this.submitError.bind(this);
    window.nextImage=this.nextImage.bind(this);
    window.filterRanking=this.filterRanking.bind(this);
  }

  shuffleArray(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} }

  loadGameData(mode){
    const ts=`?v=${Date.now()}`;
    const data=ERROR_DATA[mode];
    let allImages=[];
    data.errors.forEach(e=>allImages.push({src:CONFIG.baseURL+e.src+ts,isGood:false,correctError:e.correctError}));
    data.goods.forEach(g=>allImages.push({src:CONFIG.baseURL+g+ts,isGood:true,correctError:"ƒê·∫°t"}));
    this.shuffleArray(allImages);
    return allImages;
  }

  startGame(selectedMode){
    this.playerName=this.dom.playerNameInput.value.trim();
    if(!this.playerName){ alert("H√£y nh·∫≠p t√™n!"); return; }
    this.mode=selectedMode;
    this.images=this.loadGameData(this.mode);
    this.current=0; this.score=0; this.answered=false;
    this.dom.menu.style.display="none";
    this.dom.gameContainer.style.display="block";
    this.loadErrorOptions();
    this.loadImage();
    this.dom.rankingWrapper.style.display="none";
  }

  loadErrorOptions(){
    const list=ERROR_DATA[this.mode].errors.map(e=>e.correctError);
    this.dom.errorSelect.innerHTML="<option value=''>-- Ch·ªçn lo·∫°i l·ªói --</option>";
    list.forEach(opt=>{
      const option=document.createElement("option");
      option.value=opt; option.textContent=opt;
      this.dom.errorSelect.appendChild(option);
    });
  }

  startTimer(){
    this.timeLeft=CONFIG.timerDuration;
    this.dom.timerElement.textContent=`Th·ªùi gian: ${this.timeLeft}s`;
    this.timerInterval=setInterval(()=>{
      this.timeLeft--;
      this.dom.timerElement.textContent=`Th·ªùi gian: ${this.timeLeft}s`;
      if(this.timeLeft<=0){ clearInterval(this.timerInterval); this.autoNext(); }
    },1000);
  }

  loadImage(){
    if(this.current>=this.images.length){ this.endGame(); return; }
    this.answered=false;
    const img=this.images[this.current];
    this.dom.imgElement.src=img.src;
    this.dom.resultElement.textContent="";
    this.dom.errorSection.style.display="none";
    this.startTimer();
  }

  checkAnswer(isGood){
    if(this.answered) return;
    this.answered=true;
    clearInterval(this.timerInterval);
    if(isGood){
      this.score++;
      this.dom.resultElement.textContent="ƒê√∫ng! ƒê·∫°t";
      this.dom.resultElement.style.color="var(--success-color)";
      setTimeout(()=>this.nextImage(),500);
    } else {
      this.dom.errorSection.style.display="block";
    }
  }

  submitError(){
    const selected=this.dom.errorSelect.value;
    if(!selected){ alert("H√£y ch·ªçn lo·∫°i l·ªói"); return; }
    this.dom.resultElement.textContent="L·ªói: "+selected;
    this.dom.resultElement.style.color="var(--error-color)";
    setTimeout(()=>this.nextImage(),500);
  }

  nextImage(){
    clearInterval(this.timerInterval);
    this.current++;
    this.loadImage();
    this.dom.scoreElement.textContent=`ƒêi·ªÉm: ${this.score}`;
  }

  autoNext(){ this.answered=true; this.dom.resultElement.textContent="H·∫øt gi·ªù!"; setTimeout(()=>this.nextImage(),500); }

  endGame(){
    this.dom.gameContainer.style.display="none";
    this.dom.rankingWrapper.style.display="block";
    this.dom.finalScoreText.textContent=`Ch√∫c m·ª´ng ${this.playerName}, b·∫°n ƒë·∫°t ${this.score} ƒëi·ªÉm!`;
    this.sendScore();
  }

  sendScore(){
    fetch(CONFIG.scriptURL+"?action=add&ten_nguoi_choi="+encodeURIComponent(this.playerName)+"&muc_choi="+this.mode+"&diem="+this.score)
    .then(res=>res.json()).then(data=>{
      this.loadRanking();
    }).catch(err=>{ console.error(err); this.loadRanking(); });
  }

  loadRanking(){
    fetch(CONFIG.scriptURL+"?action=getRanking")
    .then(res=>res.json())
    .then(data=>{
      this.renderRanking(data);
    }).catch(err=>console.error(err));
  }

  renderRanking(data){
    const filter=this.dom.rankingFilter.value;
    let list=data;
    if(filter){ list=list.filter(d=>d.muc_choi===filter); }
    list.sort((a,b)=>b.diem-a.diem);
    const top10=list.slice(0,10);
    const table=this.dom.rankingTable;
    table.innerHTML=`<tr><th>STT</th><th>T√™n</th><th>Ch·∫ø ƒë·ªô ch∆°i</th><th>ƒêi·ªÉm</th></tr>`;
    top10.forEach((r,i)=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${i+1}</td><td>${r.ten_nguoi_choi}</td><td>${MODE_MAP[r.muc_choi]||r.muc_choi}</td><td>${r.diem}</td>`;
      if(r.ten_nguoi_choi===this.playerName && r.muc_choi===this.mode){ tr.classList.add("highlight"); }
      table.appendChild(tr);
    });
  }

  filterRanking(){
    this.loadRanking();
  }
}

const game=new QCGame();
</script>
</body>
</html>
